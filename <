\documentclass[a4paper,12pt,openany,oneside]{article}
\setlength{\parindent}{1cm}
%\usepackage{verbatim}
\usepackage{setspace}% Pour les interlignes
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{a4wide}
\usepackage{color}
\usepackage{fancybox}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{here}
\usepackage{short toc}
\usepackage{hyperref}
\usepackage{lastpage}
\usepackage{lscape}
\usepackage[Sonny]{fncychap}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{eiad}
\usepackage{endnotes}
\usepackage{pdfpages}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.arrows}
\usepackage{array}
\usepackage{color}
\usepackage{tabularx}
\usepackage[french,ruled,vlined]{algorithm2e} 
\usepackage{multirow}
\usepackage{pdflscape}
\usepackage{arydshln}
\usepackage{amsthm}

\usepackage{amssymb,fge}
\newcommand{\mysetminus}{\mathbin{\fgebackslash}}

\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.arrows}
\usepackage{array}
\usepackage{setspace}
\onehalfspacing
%\usepackage{titlesec}
%\usepackage{lipsum}% just to generate text for the example

\usepackage{float} %% Pour placer une figure à un endroit précis sans qu'il puisse être déplacé

\newcounter{examplecounter}
\newenvironment{example}{
\begin{quote}%
    \refstepcounter{examplecounter}%
  \textbf{Example \arabic{examplecounter}}%
  

\end{quote}%
}

 % reset theorem numbering for each chapter

%\theoremstyle{definition}
\newtheorem{defn}{Definition} % definition numbers are dependent on theorem numbers
\newtheorem{exmp}{Example} % same for example numbers
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{property}{Property}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\title{
 \begin{center}
\begin{figure}[h]
\center
  \includegraphics[scale=0.3]{logo_univ_tours}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \includegraphics[scale=0.3]{logo}\\
\end{figure}
{ \Large{Rapport de stage de Recherche}\\\vspace{2cm}
Effectué à\\
\Large{l'UNIVERSIT\'E FRAN\c{C}OIS - RABELAIS de TOURS}\\\vspace{0.5cm} Laboratoire d'Informatique, \'Equipe BDTLN\\\vspace{2cm}
\underline{ Présenté par}:\\
}
\large{\rmfamily{\textbf{KPEKPASSI Digonaou}}}
 etudiant en Master 2 Informatique (M2ITIC)\\ Université GASTON BERGER - SENEGAL\\ \vspace{2cm}
\end{center}
\underline{Encadrants}:\\
\large{
Université de TOURS\\
Arnault Giacometti \\
Arnault SOULET\\
Dominique H. Li\\
Université Gaston Berger\\
Cheick Talibouya Diop\\
}
\date{29 Juillet 2015}
}
\pagestyle{headings}
\pagestyle{fancy}
\fancyhf{}
\cfoot{\thepage}%permet de numeroter en tete à droite
\lhead{\footnotesize
\textit{\textbf{\textcolor[rgb]{0.00,0.00,0.73}
{\footnotesize\underline{Titre:} Memoire de cycle de Master}}}}
\lfoot{\scriptsize\textit{\textcolor[rgb]{0.00,0.00,0.73}
{\textbf{KPEKPASSI Digonaou}}}}
\rfoot{\scriptsize\textit{\textcolor[rgb]{0.00,0.00,0.73}}}
\renewcommand{\headrulewidth}{0.8pt}  %Trace un trait de séparation de largeur 0,4 point. Mettre 0pt pour supprimer le trait.
\renewcommand{\footrulewidth}{0.8pt}  %\renewcommand{\labelenumi}{\Roman{enumi}}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Introduction}
L'apprentissage des préférences est un domaine qui a pour but de prédire les préférences utilisateurs. Il trouve par exemple son application dans les systèmes de recommandation, dans la recherche personnalisée.\\
 Les informations que les utilisateurs considèrent comme pertinants diffèrent d'un utilisateur à un autre ce qui est en partie dû au fait que les utilisateurs n'ont pas les mêmes préférences. C'est pour cela que des méthodes utilisant des données sur les préférences des utilisateurs ont émergé afin de permettre une meilleure personnalisation des services. Les préférences utilisateurs peuvent être recueillies de deux façon, la première en demandant aux utilisateurs de fournir explicitement des informations sur leurs préférences, la seconde en recueillant implicitement ces préférences à partir des interacions entre le système et l'utilisateur. \\
Dans notre travail, c'est cette dernière approche qui nous fournit les données de préférence, ce qui dans ce cas peut contenir des données incomplètes ou inconsistences qui neccessitent des métodes d'extraction qui leur sont adaptées.\\
Dans la suite de ce document nous allons présenter un aperçut des formalisations proposées dans les travaux antérieurs, nous allons ensuite décrire l'approche que nous avons proposé puis, avec l'appuit de résultats expérimentaux, fournir une évaluation et une analyse sur l'efficacité de l'approche proposée. 

\section{Caractéristique de l'apprentissage des préférences}
L'apprentissage de préférence est caractérisé par deux étapes à savoir:
\begin{itemize}
\item Etape 1: L'apprentissage d'un modèle de préférences
\item Etape 2: La prédiction des préférences à partir du modèle de préférence appris
\end{itemize}

Le modèle de préférence est en quelque sorte une structure de règles qui a pour but de représenter de façon optimale les affinités des utilisateurs en terme de préférence.\\
Dès que le modèle de préférence est construit, on peut l'utiliser pour prédire les objets que l'utilisateur est plus succeptible de préférer.

Bien qu'ayant le même but qui est de prédire les préférences, les travaux sur l'apprentissage de préférence ont pris des approches différentes que nous pouvons distinguer par:

\begin{itemize}
\item Le \textbf{type du problème de préférence} étudié (appellé problème de classement). On peut distinguer trois types: le classement d'objet, le classement de labels et le classement d'instances.
\item le \textbf{type de modèle de préférence} construit pour prédire les préférences. Le modèle de préférence peut découler de différentes formes de combinaison de règles.
\item La \textbf{méthode de construction} du modèle de préférence.
\end{itemize}
 Ainsi nous allons par la suite décrire les types de classement qu'on rencontre puis nous énoncerons les types de modèles de préférence qui ont été proposés dans différents travaux tout en décrivant brièvement les méthodes utilisés pour leur apprentissage.

\subsection{Les types de classement}

Différentes sortes de problèmes d'apprentissage sont rencontrés. Ils sont appellés problèmes de classement et on en distingue principalement trois types:

\begin{itemize}
	\item Le classement de labels
	\item Le classement d'instances
	\item Le classement d'objets\\
\end{itemize}

Dans le cadre des notations, nous allons utiliser une terminologie qui est souvent utilisée en apprentissage supervisé. \\
Ainsi on appellera \textit{instances}, les objets de données. Chaque instance sera associé à un \textit{label de classe} déterminant l'appartenance de l'instance à une classe donnée. L'espace caractéristique des instances sera noté $\mathcal{X}$ et l'espace de sortie sera l'ensemble des labels dénoté $\mathcal{Y}$.
Les instances sont souvent représentées sous forme de vecteur caractéristique:
\[
x=(x_1,x_2,...,x_m)\in \mathcal{X}=\mathcal{X}_1\times \mathcal{X}_2\times ... \times \mathcal{X}_m
\]

Nous allons décrire ci dessous ces différents types de classement.

\subsubsection{Le classement de labels}
Soit $S_y$ l'ensemble des permutations de l'ensemble de labels $\mathcal{Y}=\{y_1,y_2,...,y_k\}$ suivant un ordre total $\succ$.\\
Le \textit{classement de labels} consiste à apprendre un classeur de labels qui est une fonction $\mathcal{C}$ définie sur $\mathcal{X}\rightarrow S_y$ et qui permet de fournir en sortie une permutation de l'ensemble $\mathcal{Y}=\{y_1,y_2,...,y_k\}$ en fonction d'une instance $x\in \mathcal{X}$ en entrée.\\
Si pour une instance $x$ on définit par $\pi_x$ une application de $\{1,2,...,k\}\rightarrow\{1,2,...,k\}$ qui à chaque indice $i$ d'un label  associe la position $\pi_x(i)$ de ce label dans la permutation $\mathcal{C}(x)$, nous obtenons:
\[
	y_{\pi_x^{-1} (1)}\succ_x y_{\pi_x^{-1} (2)}\succ_x ...\succ_x y_{\pi_x^{-1} (k)}
\]

L'ensemble d'apprentissage utilisé pour résoudre le problème de classement de labels consiste souvent en un ensemble de préférences par paires de la forme $y_i\succ_x y_j$ indiquant que $y_i$ est préféré à $y_j$ pour l'instance $x$.  

\begin{example}
Comme exemple de situations où on a affaire à un classement de label, on peut parler du classement des différentes rubriques (sport, technologie, santé etc..) en fonction des différents journaux.\\
De même on peut faire un classement de labels sur l'ordre de préférence d'un ensemble de produits (exple: logements de vacances) en fonction des caractéristiques démographiques d'une personne.\\
\end{example}

  
  \subsubsection{Le classement d'instances}
Dans le classement d'instances les éléments de $\mathcal{Y}=\{y_1,y_2,...,y_k\}$ se distinguent entre eux par un ordre naturel $y_1<y_2<...<y_k$. Chaque instance $x$ de $\mathcal{X}$ est liée à une classe de $\mathcal{Y}$. 
L'ensemble d'apprentissage pour le classement d'instance, consiste souvent à un ensemble d'instances qui ont un label déterminant leur classe d'appartenance.
Contrairement à la classification, le but n'est pas d'apprendre un classifieur mais une \textit{fonction de classement} $f(.)$ qui à partir d'un sous ensemble $X\in\mathcal{X}$ d'instances fournit en entrée, il fournit un classement ordonné de ces objets suivant la classe de chaqu'un des objets.\\
Dans le cas où on a $k=2$, ce problème est connu comme un \textit{problème de classement bipartite}. Dans le cas où $k>2$, il est considéré comme un problème de classement \textit{k-partite} ou \textit{multipartite}.

\begin{example}
Comme example, on peut prendre le cas d'un reviewer qui cherche à classer les articles en fonction de leur qualité, en les répartissant en catégories rejetés, faiblement rejetés, faiblement acceptés, acceptés.
\end{example}

  
   
\subsubsection{Classement d'objets}

Dans le cas du \textit{classement d'objets}, les instances de $\mathcal{X}$ , appellées objets, ne sont pas liés à une caractéristique en sortie (labels) comme les classements précédents. Le but est d'apprendre une fonction de classement $f(.)$ qui avec un sous ensemble $Z\in \mathcal{X}$ d'instances (appellées ici objets) fournies en entrée, donne un classement de ces objets en sortie. Ceci est souvent effectué en assignant un score à chaque instance et en ordonnant ces instances en fonction de leur score.
Comme ensemble d'apprentissage, un classeur d'objets a souvent accès à des exemples de classement entre des paires d'objets de la forme $z\succ z'$ déterminant que l'objet $z$ doit être classé au dessus de l'objet $z'$.

\begin{example}
Comme exemple, nous pouvons considérer le problème de l'apprentissage du classement des résultats de recherche d'un moteur de recherche.
\end{example}

Le classement d'objet est le classement qui nous concerne dans le cadre de notre travail. Ainsi dans la suite du document nous allons nous restreindre à ce type de classement. La section suivante décrira les différents types de modèles de préférences qui ont été proposés dans les travaux antérieurs en ce qui concerne le classement d'objet.

\section{Les types de modèles de préférence}
Les modèles de préférence peuvent être principalement catégorisés en deux types:
\begin{itemize}
\item Les \textit{modèles de préférence quantitatifs}. Ceux ci se basent sur le calcul de scores pour prédire les préférences entre les objets;
\item Le \textit{modèles de préférence qualitatifs}. Ceux ci se basent sur la construction de relations binaires pour prédire les préférences entre les objets.
\end{itemize}
Nous allons décrire  plus explicitement ces deux types de modèles de préférence rencontrés mais nous mettrons plus l'accent sur les modèles de préférence qualitatifs puisque c'est sur cette forme de représentation que reposera notre modèle de préférence.

\subsection{Modèles de préférences quantitatifs} 
Les modèles de préférences quantitatifs sont des modèles construits par apprentissage de préférence et qui calculent des scores sur des objets afin de pouvoir les comparer. \\
Comme exemple nous pouvons prendre le cas où on a deux tuples $t_1$ et $t_2$, auquels un modèle de préférence quantitatif alloue respectivement des scores de $s_{t_1}$ et $s_{t_2}$. Si $s_{t_1}>s_{t_2}$ alors le modèle détermine que $t_1$ est préféré à $t_2$.
Il y'a une panoplie de travaux qui ont été menés sur l'étude de modèles de préférences quantitatives, comme les travaux utilisant le boosting, le SVM, la descente de gradient etc.Nous n'allons pas explicité ces travaux vu que nous nous focaliseront sur les modèles de préférence qualitatifs qui sont le cadre dans lequel s'effectue notre travail.

\subsection{Modèles de préférence qualitatifs}
Les modèles de préférence qualitatifs définissent des relations binaires qui déterminent quel objet est plus préféré qu'un autre. Ces modèles de préférences peuvent se distinguer par:
\begin{itemize}
\item les propriétés caractérisant les relation binaires comme la réflexivité, la transitivité, etc..,
\item  les formulations utilisés dans ces modèles comme la représentation en formules logiques, à base de contextes contextes, etc ..,
\item  leur constitution en tant que combinaison d'autres modèles.
\end{itemize}
 Ainsi dans la suite de ce document nous allons tout d'abord faire un rappel sur différentes propriétés sur les relations binaires puis nous allons décrire les différentes formulations rencontrées dans la description des modèles de préférence qualitatifs ainsi que différentes formes de composition (combinaisons) de modèles.

\subsubsection{Propriétés qui peuvent caractériser les relations binaires}

\begin{defn}\textbf{Relation binaire}\\

Une relation binaire $\mathcal{R}$ sur un ensemble $E$ est un sous-ensemble du produit cartésien $E \times E$ c'est à dire un ensemble de couples $(x,y)$ d'éléments de E.
Nous noterons $x\mathcal{R}y$ pour indiquer que le couple (x,y) appartient à la relation $\mathcal{R}$.

\end{defn}

Une relation binaire est:

\begin{itemize}
        \item réflexive si $\forall x\in E,\; x\mathcal{R}x$
        \item irréflexive si $\forall x\in E,\; \neg(x\mathcal{R}x)$
        \item symétrique si $\forall x,y\in E,\; x\mathcal{R}y\Rightarrow y\mathcal{R}x$
        \item antisymétrique si $\forall x,y\in E,\; x\mathcal{R}y\wedge y\mathcal{R}x\Rightarrow x=y$
        \item asymétrique si $\forall x,y\in E,\; x\mathcal{R}y\Rightarrow \neg(y\mathcal{R}x)$
        \item complète si $\forall x,y\in E, x\mathcal{R} y\vee y\mathcal{R}x$
        \item transitive si $\forall x,y\in E, x\mathcal{R} y\wedge y\mathcal{R}z\Rightarrow x\mathcal{R}z$
        \item négativement transitive si $\forall x,y\in E, \neg (x\mathcal{R} y)\wedge \neg (y\mathcal{R}z)\Rightarrow \neg(x\mathcal{R}z)$

\end{itemize}


\begin{defn}\textbf{Indifférence par rapport à une relation}
        Etant donnée une relation $\mathcal{R}$  sur un ensemble $E$, et un couple $(x,y)\in E\times E$, $x$  est indifférent à $y$ par rapport à $\mathcal{R}$ (noté $x\tilde{\mathcal{R}}y$) si on a $x\mathcal{R}y\wedge y\mathcal{R}x$.
\end{defn}

\begin{defn}\textbf{Incompatibilité par rapport à une relation}
        Etant donnée une relation $\mathcal{R}$ sur un ensemble $E$, et un couple $(x,y)\in E$, $x$ est incompatiple à $y$ par rapport à la relation $\mathcal{R}$ (noté $x||_\mathcal{R}y$) si $\neg(x\mathcal{R}y)\wedge\neg (y\mathcal{R}x)$
\end{defn}

\begin{defn}\textbf{Relation d'ordre}
        On appelle relation d'ordre sur un ensemble $E$, toute relation binaire sur E qui est réflexive, antisymétrique et transitive.
\end{defn}

Si la relation d’ordre est complète, c'est à dire tous les éléments de $E$ sont comparables par cette relation, elle est appellée relation d'ordre totale sinon ele est appellée relation d'ordre partiel.

\begin{defn}\textbf{Préordre}
Un préordre sur un ensemble E est une relation binaire réflexive et transitive.
\end{defn}

\begin{defn}(Relation d’ordre strict)
 Une relation d’ordre strict sur un ensemble E est une relation binaire irréflexive et transitive. L’ordre strict est dit faible, s’il est partiel et négativement transitif.
\end{defn}



\subsubsection{Formulations rencontrés dans les modèles de préférence qualitatives}

Les règles constituant les modèles de préférences qualitatives peuvent être représentées par différentes formulations que nous allons exposer dans la suite de cette sous-section.

\begin{enumerate}
\item \textbf{Formulations à base de formules logiques}
Les travaux de \cite{CHO} nous montrent comment peuvent être utiliées les formules logiques pour décrire les modèles de préférence. En effet dans ces travaux on parle de formules de préférences qui sont des formules logique de premier ordre appliquées à des couples de transactions afin de déterminer lequel est plus préféré. Elles sont sous la forme:
\[
	C(t_1,t_2)=\bigvee\limits_{i=1}^k\bigwedge\limits_{j=1}^{k_i}f_{ij}
\]
\begin{example}
                        Soit deux transactions $t_1=\{x_1,x_2,x_3\}$ et $t_2=\{y_1,y_2,y_3\}$ d'une instance de la relation R(Plat,TypePlat, TypeVin). On a qu'ils vérifient la formule de préférence $C$ si et seulement si
                        \[
                                \begin{array}{rcl}
                                C(t_1,t_2)&\equiv&(x_1=y_1\wedge x_2="fish"\wedge y_2="fish"\wedge x_3="white"\wedge y_3="red")\\
                                &&\vee (x_1=y_1\wedge x_2="meat"\wedge y_2="meat"\wedge x_3="red"\wedge y_3="white")
                                \end{array}
                        \]
                         est vérifié. Cette condition veut dire que dans le cas où c'est un plat à base de poisson, le client préfère le vin blanc au vin rouge et dans le cas où c'est un plat à base de viande, le client préfère le vin rouge au vin blanc.

\end{example}

\item \textbf{Formulations à base de contextes}
Les préférences entre les objets peuvent varier en fonction du contexte dans lequel ils se trouvent. Par exemple lorsque l'on prend des films, en fonction d'un contexte commun aux deux films comme le cas où les deux films sont des films de comédie, on peu préférer ceux où jouent certains acteurs alors que ceux ci peuvent ne pas être les plus préférés dans le contexte où c'est des films d'action. Tout dépend ainsi du contexte qui est ici la catégorie du film. \\
Différents travaux ont recours à l'utilisation de contextes dans la définition de leur modèles. Ainsi nous pouvons parler:\\
	\begin{itemize}
		\item Des \textbf{CP-nets}. Soit $\mathcal{A}=\{A_1,...,A_n\}$ un ensemble d'attributs d'objets. Un CP-nets sur $\mathcal{A} $ est un graphe direct dans lequel il existe un noeud pour chaque attribut $A_i$ de $\mathcal{A}$. Si pour deux attribut $A_i,A_j$ on a une flèche du noeud de $A_i$ vers le noeud de $A_j$, alors $A_i$ est appellé un parent de $A_j$. L'ensemble de tous les parents d'un attribut $A_i$ est noté $P(A_i)$. Pour chaque attribut $A_i$, son noeud dispose d'une table de préférence conditionnelle $CPT(A_i)$ qui contient un ensemble de règles de préférence conditionnelles de la forme $z_i:a_{i_1}\succ a_{i_2}$ où $z_i\in dom(Pa(A_i))$ et $a_{i_1},a_{i_2}$ appartiennent à $dom(A_i)$. Ces règles signifient: étant donné $z_1$ (dans notre cas ici c'est une forme de contexte), $a_{i_1}$ est strictement préféré à $a_{i_2}$ ceteris paribus (toute autre chose étant égale: c'est à dire que la règle est vraie quelle que soient les autres valeurs prises au niveau des attributs de $\mathcal{A}\mysetminus(\{A_i\}\cup P(A_i))$.\\
En des termes plus simples, cette règle de préférence indique qu'un tuple contenant $z_i$ et $a_{i_1}$ est préféré à un tuple contenant $z_i$ et $a_{i_2}$ en considérant que les valeurs des tuples sur les autres attributs sont les mêmes.

\begin{example}
        Cas des préférences au niveau des plats de riz. L'utilisateur préfère accompagner le riz au poisson plutôt qu'à la viande, et dans le cas du spagetti, il préfère la viande au poisson.\\
        \begin{center}
                   \begin{tabular}{|l|l|}
                   \hline
                                Riz & Poisson$\succ$ Viande\\
                                \hline
                                Spaghetti & Viande$\succ$ Poisson\\
                                \hline
                   \end{tabular}
        \end{center}
\end{example}

\bigskip


L'ensemble de ces tables de préférences conditionnelles vont former les CP-nets comme on peut le voir au niveau de l'exemple ci dessous.

\begin{example}
Meme genre que l'exemple précédent.

        \begin{center}

                \begin{tikzpicture}[
                        auto,
                        block/.style    = { draw=blue,circle, thick,
                                            fill=blue!20, text width=2em, text centered,
                                             minimum height=1em },
                        line/.style     = { draw, thick, ->, shorten >=2pt },
                      ]
                      % Define nodes in a matrix
                      \matrix [column sep=2mm, row sep=10mm] {
                             & \node [block,label=right:                           
						\begin{tabular}{|l|l|}
        			                  \hline
	                                        Poisson$\succ$ Viande\\
                                        	\hline
                           			\end{tabular}
				   ] (PU) {Plat};& \\
                             & \node [block,label=right:
					 \begin{tabular}{|l|l|}
				                \hline
                	        	        Poisson: Riz $\succ$ Spaghetti\\
        	                        	\hline
		                                Viande: Spaghetti $\succ$ Riz\\
        	                        	\hline
                			\end{tabular}
					] (TP) {Garn};& \\
                    };
                      % connect all nodes defined above
                      \begin{scope} [every path/.style=line]
                                \path (PU)    --    node [near start] {}
                                (TP);

                      \end{scope}

                    \end{tikzpicture}
             \end{center}

       \end{example}
\bigskip
Soit un CP-nets N sur $\mathcal{A}$. Soit $A_i$ un attribut de $\mathcal{A}$ et $Y=\mathcal{A}\mysetminus(Pa(A_i)\cup{A_i})$.\\
Pour toute instance $z_i$ de $Pa(A_i)$ on associe l'ordre $\succ_{z_i}^i$ induit sur $dom(A_i)$ par la table de préférence $CPT(X_i)$a.\\

Une relation de préférence $\succ$ satisfait $\succ_{z_i}^i$ ssi pour $y\in dom(Y)$ et $a_{i_1},a_{i_2}\in dom(A_i)$, si $ya_{i_1}z_i\succ ya_{i_2}z_i$ alors $a_{i_1}\succ_{z_i}^i a_{i_2}$.\\
Une relation de préférence satisfait $CPT(A_i)$ ssi elle satisfait $\succ_{z_i}^i$ pour chaque $z_i\in dom(Pa(A_i))$.\\
Une relation de préférences $\succ$ satisfait le CP-net N ssi elle satisfait $CPT(A_i)$ pour chaque $A_i$.\\

Ainsi un modèle de préférence basé sur le CP-net est une relation de préférence qui satisfait le CP-net.\\

\item Des \textbf{règles de préférence contextuelles}
Une paire de transaction est une paire sous la forme $\left<t_1,t_2\right>$ avec $t_1$ et $t_2$ des transactions caractérisant des objets. Cette paire décrit le fait que $t_1$ est préféré à $t_2$. Nous les utiliseront pour décrire les règles de préférence contextuelles.\\
Les règles de préférence contextuelles ont été étudiées dans les travaux de \cite{AGR},\cite{AMO}, \cite{GIA}. Elles ont une formulation similaire aux règles de préférence conditionnelles (CP-nets). Exemple avec des ensembles $C,X,Y$ disjoints la règle $C\rightarrow X\succ Y$ veut dire que pour toutes transactions $t_1$ et $t_2$ qui ont en commun le contexte $C$, et $t_1$ contient $X$ et ne contient pas  $Y$ et $t_2$ contient $Y$ et ne contient pas $X$, alors $t_1$ est préféré à $t_2$. La différence avec les CP-nets est la manière dont les règles sont utilisées dans le modèle de préférence. En effet la caractéristique des règles de préférences contextuelles est qu'elles sont disposées sous forme de liste ordonnée dans les modèles de préférences. Différentes règles de tri peuvent être utilisées pour ordonner la liste des règles dans les modèles de préférences. Par exmple la méthode \textit{best rule} permet de classer les règles suivant la valeur de leur confidence (taux de paires de transactions vérifiant la règle parmis les paires de transactions contenant le contexte de la règle) ensuite si la valeur de la confidence est égale, les règles sont triées suivant la valeur du support (taux de paires de transations vérifiant la règle parmis toutes les transactions de la base).

\begin{example}
 		La règle de préférence contextuelle $\{Action\}\rightarrow \{1990\}\succ \{2000\}$ signifie que dans le cas de films d'action, l'utilisateur préfère les films de 1990 aux films de 2000.\\ 		
\end{example}
	\end{itemize}

\item \textbf{Formulations lexicographiques}
Dans le modèle de préférence lexicographique, les préférences sont définies sur les attributs et sur un ordre d'importance entre les attributs. Ainsi si on a deux attributs munis de leur relation de préférence $(A_i,\succ_i)$ et $(A_j,\succ_j)$ de telle sorte que $A_i$ est plus important que $A_j$ par rapport à la préférence lexicographique $\succ \equiv \succ_i \&\succ_j$, alors pour deux transactions $t_1,t_2$, $t_1\succ t_2$ ssi $(t_1.a_i\succ_i t_2.a_i)\vee (t_1.a_i=t_2.a_i\wedge t_1.a_j\succ_j t_2.a_j)$ avec $t_1.a_k,t_2.a_k\in A_k,k=1,2$. 

\begin{example}
Soit le modèle lexicographique sur deux attributs \textit{genre} et \textit{directeur} de telle sorte que l'attribut \textit{genre} est plus important que \textit{directeur}. Sur l'attribut genre, on a que $comedy\succ_{genre} drame$ et sur l'attribut directeur, on a $W.Allen\succ_{directeur} M.Curtis$. Si l'ensemble des transactions est $t_1=\{comedy, W.allen\}$, $t_2=\{comedy, M.Curtiz\}$, $t_3=\{drame, W.Allen\}$, $t_4=\{drame, M.Curtiz\}$ avec le premier attribut étant le genre et le deuxieme le directeur, alors l'ordre lexicographique $\succ\equiv \succ_{genre}\&\succ_{directeur}$ classe ces transaction de la manière suivante:
\[
	t_1\succ t_2\succ t_3\succ t_4
\]
\end{example}

\item \textbf{Modèle de pareto}
Dans le modèle de préférence pareto c'est les préférences sur les attributs des objets qui sont mis en avant. Aini il y'a une relation de préférence $\succ_i$ sur chaque attribut $A_i$ de telle sorte que pour le modèle de préférence de pareto $\succ$, $t_1\succ t_2$ ssi $t_1.a_i\succ_i t_2.a_i$ avec $t_1.a_i,t_2.a_i\in dm(A_i)$ pour tout attribut $A_i$ de l'ensemble des attributs $\mathcal{A}=\{A_1,A_2,...,A_n\}$. On note $\succ\equiv \succ_1\otimes\succ_2\otimes ...\otimes\succ_n$. On constate que contrairement au modèle de préférence lexicographique, les attributs ont la même importance.
\end{enumerate}



\subsubsection{Compositions des modèles de préférences qualitatives}
Les modèles de préférences peuvent être combinés pour former des modèles de préférence plus complexes. Ainsi nous présentons ci dessous des approches qui exposent certaines formes de combinaisons possibles entre des relations de préférence qui représentent des modèles de préférence.
\begin{enumerate}

\item \textbf{Composition de préférence prioritaires}
La composition de préférence prioritaire prend en compte la notion de priorité entre les relations de préférence. Ainsi si on a deux relations $\succ_i$ et $\succ_j$, alors la préférence prioritaire $\succ_i\&\succ_j$ est définie par: pour deux transactions $t_1,t_2$, $t_1\succ_i\&\succ_j t_2 \Leftrightarrow (t_1\succ_i t_2)\vee(t_1\sim_i t_2\wedge t_1\succ_j t_2)$.

\item \textbf{Composition de pareto}
La composition de pareto de deux relations de préférences $\succ_l$ et $\succ_m$ est une composition définie par :
\[
	\forall t_i,t_j\in R, t_i\succ_l\otimes\succ_m t_j ssi (t_i\succ_l t_j\wedge \neg (t_j\succ_m t_i))\vee(t_i\succ_m t_j\vee \neg(t_j\succ_l t_i))
\] 
\end{enumerate}




Après la description des différentes sortes de modèles de préférence, nous allons nous focaliser sur l'étude des modèles de préférence à base de règles de préférence contextuelles (que nous avions présenté antérieurement) de même que l'étude de la formalisation à base de formules de préférence, cs deux approches étant le socle de notre travail.


 
 \section{Modèles de préférence à base de règles de préférence contextuelle}
 	

	Soit $\mathcal{R}(R_{1},R_{2},...,R_{n})$ un schémas relationnel tel que pour chaque attribut $R_{i}$ on note son domaine de valeurs par $Dom(R_{i})$. 
	Ainsi notons $Dom(\mathcal{R})=Dom(R_{1})\times Dom(R_{2})\times ...\times Dom(R_{n})$. On appelle une \textbf{transaction}, tout élément de $Dom(\mathcal{R})$. 
	Soit $\mathbf{I}=\bigcup_{1}^{n}Dom(R_{i})$, tout élément $i$ tel que $i\in \mathbf{I}$, est appelé \textbf{item}.
	En prenant une transaction $T={i_1,i_2,...,i_n}$, tout éléménent $I$ tel que $I\in T$ est appelé \textbf{itemset}.
        Une \textbf{base de transactions} est un ensemble de transactions, chacun associé à un identifiant unique.	
	Une \textbf{paire de transactions} $\left<T_1,T_2\right>$ est un vecteur de transactions tel que $\left<T_1,T_2\right>\neq \left<T_2,T_1\right>$
 
	\begin{example}
 		Soit un schémas relationnel $\mathcal{R}(Genre, Acteur, Annee)$. Leur domaines de valeurs peuvent être les suivants:  $Dom(Genre)=\{Action, Aventure, Guerre,Comedie\}$, $Dom(Acteur)=\{Pierce Brosman, Sylvester Stalone, Harrison Ford\}$ et $Dom(Annee)=[1900;2020]$. $Dom(A)=Dom(Genre)\times Dom(Acteur)\times Dom(Annee)$ Ainsi $T=\{Action,Pierce Brosman,2010\}$ est une transaction de $Dom(A)$. $T'=\{Action,2010\}\in T$ est alors un itemset.
 	\end{example}
 	 
 \subsection{Préférences utilisateur}

 	\begin{defn}(Préférence utilisateur)\\
 		Une \textbf{préférence utilisateur} est une paire de transactions $\left<T_{1},T_{2}\right>$ qui spécifie que l'utilisateur préfère $T_{1}$ à $T_{2}$. Elle est aussi écrite sous la forme $T_{1}\succ T_{2}$.\\
 	\end{defn}

	\begin{defn}(Base de préférence)\\
 		Soit $\mathcal{D}$ un ensemble de transactions. Une \textbf{base de préférence}  $\mathcal{P}=\mathcal{D}\times\mathcal{D}$ d'un utilisateur est un ensemble de préférences utilisateur.\\
 	\end{defn}

 	\begin{defn}(Règle de préférence contextuelle)\\
		Soit des itemsets $C,X,Y$.
 		Une \textbf{règle de préférence contextuelle} est une représentation de la forme $C\rightarrow X\succ Y$  signifiant que lorsque l'itemset $C$ est observé, l'utilisateur préfère l'itemset $X$ à l'itemset $Y$.\\
		$C$ est appellé \textit{itemset contextuel}, $X$ est appellé \textit{itemset préféré} et $Y$ \textit{itemset non préféré}
 	\end{defn}

 	\begin{example}
 		La règle de préférence contextuelle $\{Action\}\rightarrow \{1990\}\succ \{2000\}$ signifie que dans le cas de films d'action, l'utilisateur préfère les films de 1990 aux films de 2000.\\ 		
 		La règle de préférence contextuelle $\{MemeGenre\}\rightarrow \{Avant \;2000\}\succ \{Apres\;2000\}$ signifie que dans le cas où deux films sont de même genre, l'utilisateur préfère les films produits au delà de l'année 2000.\\
 	\end{example}
 

\begin{defn}	
        Deux transactions sont \textbf{comparables} suivant la règle $C\rightarrow X\succ Y$ si les deux contiennent $C$ et si une des deux contient $X$ et l'autre $Y$.\\
\end{defn}
\begin{defn}
 	On dit qu'une préférence $\left<T_{1},T_{2}\right>$ \textbf{supporte} une règle de préférence contextuelle $\mathcal{R}=C\rightarrow X\succ Y$ (noté $R\vdash^+ \left<T_1,T_2\right>$)  si $C\in T_{1}\cap T_{2}$,  $X\in T_{1}\backslash T_{1}\cap T_{2}$ et $Y\in T_{2}\backslash T_{1}\cap T_{2}$.\\
\end{defn}
\begin{defn}	
On dit qu'une préférence $\left<T_{1},T_{2}\right>$ \textbf{contredit} une règle de préférence contextuelle $\mathcal{R}=C\rightarrow X\succ Y$  (noté $R\vdash^- \left<T_1,T_2\right>$) si $C\in T_{1}\cap T_{2}$,  $Y\in T_{1}\backslash T_{1}\cap T_{2}$ et $X\in T_{2}\backslash T_{1}\cap T_{2}$.\\
\end{defn}

 	\begin{example}
 		Avec $T_{1}=\{Action,Pierce\; Brosman,1990\}$ et $T_{2}=\{Action, Sylvester\; Stalone, 2000\}$, on constate que $<T_{1},T_{2}>$ supporte la règle de préférence $\{Action\}\rightarrow \{1990\}\succ \{2000\}$.\\
 	\end{example}
 	
De même on dit qu'une transaction $T_{1}$ est \textbf{préférée} à une transaction $T_{2}$ suivant une règle contextuelle $\mathcal{R}=C\rightarrow X\succ Y$ et noté $T_{1}\succ_{\mathcal{R}} T_{2}$ si si $C\in T_{1}\cap T_{2}$ (resp $T_{1}$ et $T_{2}$ vérifient $C$) et si $Y\in T_{1}\backslash T_{1}\cap T_{2}$ (resp seul $T_{1}$ vérifie $Y$) et $X\in T_{2}\backslash T_{1}\cap T_{2}$ (resp seul $T_{2}$ vérifie $X$).\\
 	
 
	Soit une règle de préférence $r$ et une base de données de préférences $\mathcal{P}$. \\
	Nous définissons par:\\

	\begin{itemize}
		\item $agree(r,\mathcal{P})$ l'ensemble des préférences qui supportent $r$;
			\[
				agree(r,\mathcal{P})=\{\left<T_{i},T_{j}\right>\in \mathcal{P}/R\vdash^+ \left<T_{i},T_{j}\right >\}
			\]
		\item $contradict(r,\mathcal{P})$ l'ensemble des préférences qui contredisent $r$; 
			\[
				contradict(r,\mathcal{P})=\{\left<T_{i},T_{j}\right>\in \mathcal{P}/R\vdash^- \left<T_{i},T_{j}\right >\}
			\]
	
		\item $cover(i,\mathcal{P})$ l'ensemble des préférences qui supportent et contredisent $r$
			\[
			 	cover(r,\mathcal{P})=agree(r,\mathcal{P})\cup contradict(r,\mathcal{P})
			\]
	\end{itemize}
  
    	\begin{defn}
    		Le \textbf{support} d'une règle de préférence dans une base de préférence $\mathcal{P}$ est le rapport entre le nombre de préférences qui supportent la règle de préférence et le nombre total des préférences de la base de préférence:
    		\[
    			supp(r)=\frac{agree(r,\mathcal{P})}{|\mathcal{P}|}
		\]
    		
    		
    	\end{defn}
    	\begin{defn}
    		La \textbf{confiance} d'une règle de préférence quand à elle est le taux de transactions vérifiant la règle par rapport à la somme du nombre de transactions vérifiant et du nombre de transactions contredisant la règle.
    		\[
    			conf(r)=\frac{|agree(r,\mathcal{P})|}{|cover(r,\mathcal{P})|}
    		\]
    	\end{defn}


    	\begin{defn}(Règle de préférence fréquente)
    		Une règle de préférence $r$ est dite fréquente par rapport à un seuil $\sigma$ si $supp(r)\geq \sigma$
	\end{defn}
    	\begin{defn}(Règle de préférence interressante)
		Une règle de préférence est dite interressante pour un seuil de support $\sigma$ et un seuil de confiance $\delta$ si elle est fréquente par rapport au seuil $\sigma$ et si elle a une confiance $conf(r)\geq\delta$.
	\end{defn}


    		

\begin{defn}(Règle de préférence minimale)
Une règle de préférence contextuelle $r=C\rightarrow X\succ Y$ est \textbf{minimale} par rapport à une base de préférences utilisateurs $\mathcal{P}$ si et seulement s'il n'existe aucune règle $r'=C'\rightarrow X'\succ Y'$ avec $r\neq r'$, tel que $C'\subseteq C$, $X'\subseteq X$ et $Y'\subseteq Y$ avec $supp_\mathcal{P}(r)=supp_\mathcal{P}(r')$ $conf_\mathcal{P}(r)=conf_\mathcal{P}(r')$.
\end{defn}

\begin{defn}(Modèle de préférences)
Un \textbf{modèle de préférence} $\mathcal{M}_\mathcal{P}$ sur une base de préférence $P$ est un ensemble trié et ordonné de règles de préférences contextuelles interressantes minimales.
\end{defn}
Dans le cadre d'un utilisateur, le modèle de préférence de la base de préférence de cet utilisateur est appelé \textbf{profile de préférences} de cet utilisateur.
Ce profil de préférence est construit de façon à ce qu'il soit \textbf{précis} et \textbf{concis} par rapport à la base de préférences utilisateur. Le critère de concision est évalué par la cardinalité du profil de préférence (recherche de profils à faible cardinalité). Le critère de précision quand à lui est évalué par une \textbf{fonction de coût} que nous allons définir dans la suite de ce document.\\


	On peut étendre les notations agree,contradict et cover à un ensemble de règles de préférences de la manière suivante:\\
	\begin{itemize}
		\item $agree(\Pi,\mathcal{P})=\cup_{\pi \in \Pi} agree(\pi,\mathcal{P})$;
		\item $contradict(\Pi,\mathcal{P}) =\cup_{\pi\in\Pi}contradict(\Pi,\mathcal{P})$;
		\item $cover(\Pi,\mathcal{P})=\cup_{\pi\in\Pi}cover(\Pi,\mathcal{P})$\\
	\end{itemize}


\begin{defn}(fonction coût)
Etant donné une base de préférences $\mathcal{P}$ et un ensemble de règles de préférences contextuelles $\Pi$, le coût de l'ensemble $\Pi$ par rapport à $\mathcal{P}$ noté $Cost(\Pi,\mathcal{P})$ est défini par:
\[
cost(\Pi,\mathcal{P})=\frac{|\mathcal{P}\mysetminus cover(\Pi,\mathcal{P})|+|contradict(\Pi,\mathcal{P})|}{|\mathcal{P}|}
\]
\end{defn}

\section{Utilisation des motifs séquentiels dans le cadre des préférences contextuelles (approche Sprex)}

Le travail effectué par  Giacometti et al. a permis de proposer un mode d'extraction de profil utilisateur inspiré de l'extraction des motifs séquentiels.Ils ont nommé cette approche \textbf{Sprex}(Sequence-pattern based preference rule extraction).\\
Ainsi une nouvelle forme de représentation des préférences utilisateurs a été proposée de façon à être similaire à la représentation utilisée dans les motifs séquentiels.
Nous allons dans les sous sections suivantes décrire cette nouvelle représentation et les différentes étapes de Sprex qui permettent de construire les profils de préférence (à l'aide de son module nommé \textbf{Sprex-Build}) et prédire les préférences (à l'aide de son module nommé \textbf{Sprex-Predict}). 

\subsection{Représentation séquentielle des préférences}
Soit I l'ensemble de tous les items. Un item de préférence est une paire $L:i$ où $L\in \{C,P,N\}$ est un label (avec $C\equiv $ Contexte, $P\equiv $ Préféré, $N\equiv $ Non-préféré) et i un item de $\mathcal{I}$.
Soient deux transactions $T_1$ et $T_2$ telles que $T_1\succ T_2$. Dans leur cas, on défini par:

\begin{itemize}
\item \textbf{Itemset contextuel} l'ensemmble d'items de préférence $C=\{C:c_1,C:c_2,...,C:c_k\}$ tel que $\{c_1,c_2,...,c_k\}= T_1\cap T_2$
\item \textbf{Itemset préféré} l'ensemmble d'items de préférence $P=\{P:x_1,P:x_2,...,P:x_k\}$ tel que $\{x_1,x_2,...,x_k\}= T_1 \mysetminus T_2$
\item \textbf{Itemset non préféré} l'ensemmble d'items de préférence $N=\{N:y_1,N:y_2,...,N:y_k\}$ tel que $\{y_1,y_2,...,y_k\}= T_2\mysetminus T_1$
\end{itemize} 
Ces types d'itemsets sont appelés \textbf{itemsets de préférence}.
La \textbf{base de séquences de préférence} $\mathcal{P}$ correspondant à une \textbf{base de préférence} est l'ensemble des séquences de préférence qui correspondent à une préférence unique de la base de préférence.
Dans ce cas on calcule le support $supp$ d'une séquence de préférence $s$ en comptant le nombre de séquences de préférence $s'$ de la base de séquence de préférence qui contiennent $s$.  
\[
	supp(s)=\{s'\in \mathcal{P}/s\subset s'\}
\]
On appelle \textbf{séquence de préférence} la séquence $\left<CPN\right>$ qui est une liste ordonnée des itemsets $C$,$P$,$N$ représentant la transaction de préférence $\left<T_1,T_2\right>$ avec $T_1=C\cup P$ et $T_2=C\cup N$.\\
Une règle de préférence contextuelle $C\rightarrow X\succ Y$ où $C=\{c_1,c_2,...,c_k\}$ , $X=\{x_1,x_2,...,x_3\}$, $Y=\{y_1,y_2,...,y_3\}$, peut être écrite sous forme de séquence de préférence $\left<C_C X_P Y_N\right>$.


Soit la paire de transactions $\left< T_1,T_2\right>$ dont la séquence de préférence correspondante est $\left<I_C I_P I_N\right>$. Ainsi:
\[
	C\rightarrow X\succ Y\; supporte \left<T_1,T_2\right> \Leftrightarrow  \left<C_C X_P Y_N\right> \subseteq \left<I_C I_P I_N\right>
\]
\[
	C\rightarrow X\succ Y\; contredit \left<T_1,T_2\right> \Leftrightarrow  \left<C_C X_P Y_N\right> \subseteq \left<I_C I_N I_P\right>
\] 


Ces correspondances nous permettent de déduire que le support d'une règle de préférence  $C\rightarrow X\succ Y$ est égal au support de la séquence de préférence $\left<C_C X_P Y_N\right>$ qui lui correspond.
De même le nombre de paires de préférence qui contredisent cette règle correspond au nombre de séquences de préférences qui supportent  $\left<C_C Y_P X_N\right>$.

\subsection{Description de la construction du profil de préférence par Sprex-Build}
Sprex-Build est la composante de Sprex dont le rôle est de permettre la construction d'un profil utilisateur (modèle de préférence) $\mathcal{M}_\mathcal{P}$ à partir d'une base de préférences utilisateur $\mathcal{P}$ en considérant un seuil minimal de support $\sigma$, un seuil minimal de confiance $\delta$ et en utilisant une fonction de modélisation $\pi$ (choisie par l'utilisateur).\\ 
Sprex build génère d'abord une base de séquences de préférences $\mathcal{P}_S$ à partir de la base des préférences de l'utilsateur $\mathcal{P}$ en convertissant les couples de transaction de préférence en séquence de préférence comme vu précédamment.\\
Suite à cela, l'ensemble des séquences fréquentes de préférences $\mathcal{F}$ est extrait de $\mathcal{P}_S$ en sélectionnnant toutes les séquences fréquentes dont le support $supp$ est au dessus du seuil $\sigma$ (en utilisant n'importe quel algorithme d'extraction de motifs séquentiels: dans le cas de Sprex c'est lapproche \textbf{Patterngrowth} qui est utilisée). Sprex-build calcule ensuite pour chaque séquence fréquente de préférence sa confiance $conf_{\mathcal{P}_S}$ et l'ajoute au modèle $\mathcal{M}$ à condition que $conf_{\mathcal{P}_S}\geq \delta$. Ensuite une fonction de modélisation est utilisée pour construire le modèle de préférence final. \\
Voici ci dessous ces étapes résumées sous forme d'algorithme.\\



\begin{algorithm}[H]
	\Entree{l'ensemble des préférences de l'utilisateur $\mathcal{P}$, un seuil minimal de support $\delta$, un seuil minimal de confiance $\sigma$ et une fonction de modélisation $\pi$}
 	\Sortie{Modèle de règles de prférences $\mathcal{M}_\mathcal{P}$}
 	   	
 	   	\Deb{
 	   		$\mathcal{P}_S=\emptyset$\;
 	   		\PourCh{$\left<T,U\right>\in \mathcal{P}$}{
				$C_c=\lambda_C(T\cap U), P_p=\lambda_P(T\mysetminus T\cap U), N_N=\lambda_N(U\mysetminus T\cap U)$\;
				$\mathcal{P}_S=\mathcal{P}_S\cup \left< C_C P_P N_N\right>$\;
			}
			$\mathcal{F}=FrequentSequenceMining(\mathcal{P}_S,\sigma)$\;
			$\mathcal{M}=\emptyset$\;

			
 	   		\PourCh{$s\in \mathcal{F}$}{
				\Si{$conf_{\mathcal{P}_S} \geq \delta$}{
					$\mathcal{M}=\mathcal{M}\cup s$\;
				}
			}
			$\mathcal{M}_\mathcal{P}=\pi(sort(\mathcal{M}))$\;
			\textbf{Retourner} $\mathcal{M}_{\mathcal{P}}$;
 			}
	\caption{Sprex-Build}
\end{algorithm}

Nous avions décrit antérieurement ce que c'est qu'un profil utilisateur et qu'il se doit de vérifier les critères de précision et de concision. Pour vérifier ces critères, Sprex le construit de la manière suivante:
\begin{itemize}
\item \textbf{A compléter}
\end{itemize}






\subsection{Description de l'approche utilisée pour la prédiction des préférences utiliateurs (Sprex-Predict)}

Sprex-Predict est le module de Sprex permettant d'effectuer des prédictions entre deux préférences. Nous le décrivons dans la suite du document.

Etant donné un modèle de préférences $\mathcal{M}$, une \textbf{fonction de préférences} $\rho$ retourne un score $c$ entre 0 et 1 qui prédit entre les transactions $T$ et $U$, celle que l'utilisateur préfère en s'inspirant du modèle $\mathcal{M}$.
\begin{itemize}
\item Si $c>0.5$, il est prédit que l'utilisateur va préférer $T$ à $U$;
\item Si $c<0.5$, il est prédit que l'utilisateur va préférer $U$ à $T$;
\item Autrement si $c=0.5$, Sprex-Predict retourne qu'il y'a une indécision au niveau du choix du plus préféré.
\end{itemize}

La fonction de préférence utilise des règles du modèle afin de déterminer quelle est la transaction la plus préférée. 
Une approche simple est \textbf{best rule} $r_{best}$ définit par: si $T$ est préféré à $U$ alors $r_{best}$ retourne une valeure $conf_\mathcal{P}(R_{best})$ ($>0.5$), si $U$ est préféré à $T$, $r_{best}$ retournera $1-conf_\mathcal{P}(r_b)$ ($<0.5$), autrement dans le cas de l'indécision ($T\sim U$), $r_{best}$ va retourner la valeur $0.5$.\\
Malheureusement cette fonction mêne souvent à l'indécision suivant une étude de (de Amo et al. 2012) d'où Sprex-Predict utilise une fonction de préférence basée sur \textbf{range voting} (vote par valeur) qui se décrit sous forme d'une élection où les transactions d'un ensemble $\mathcal{E}$ votent pour les candidats $U$ ou $T$ de telle façon que chaque transaction accorde à chaque candidat la valeur retournée par $r_{best}$ de la paire de transaction $\left<candidat,votant\right>$. Ces valeurs sont ensuite sommées pour chaque candidat et celui ayant le plus haut score est le gagnant. \\
Ci dessous voici $\rho_{vote}$ qui retourne 1 si la valeur totale du vote de $T$ est supérieure à celle de $V$, 0 si celle de  $V$ est supérieur à celle de $T$ et 0.5 si les deux valeurs sont égales.


\[\rho_{vote}=
\left \{
\begin{array}{c c}
    1, si \sum_{V\in \mathcal{E}}\rho_{best}(\mathcal{M},\left<T,V\right>)>\sum_{V\in\mathcal{E}}\rho_{best}(\mathcal{M},\left<U,V\right>) \\
    0, si \sum_{V\in \mathcal{E}}\rho_{best}(\mathcal{M},\left<T,V\right>)<\sum_{V\in\mathcal{E}}\rho_{best}(\mathcal{M},\left<U,V\right>) \\
    0.5, si \sum_{V\in \mathcal{E}}\rho_{best}(\mathcal{M},\left<T,V\right>)=\sum_{V\in\mathcal{E}}\rho_{best}(\mathcal{M},\left<U,V\right>) \\
\end{array}
\right.
\]



\section{Extraction des préférences contextuelles dans notre approche}

Sprex s'est basé sur l'efficacité des méthodes d'extraction des motifs séquentiels afin de l'appliquer à l'extraction des profils de préférence utilisateur. De même contrairement aux précédents travaux qui permettaient de comparer des items un à un en fonction d'un contexte (repésentation des règles limitées à la forme $C\rightarrow i_1\succ i_2$ avec $i_1$, $i_2$ des items et $C$ un itemset), Sprex a permit d'améliorer l'approche en permettant d'étendre la comparaison à des itemsets(ensemble d'items) en fonction d'un contexte (représentation des règles sous la forme $C\rightarrow X\succ Y$ avec $X$,$Y$ et $C$ tous des itemsets). Cette extension des possibilités de comparaison, a permit l'enrichissement de l'expressivité des règles de préférences extraites et ainsi du profil utilisateur.\\ 
Suite à cela, différentes approches ont étés étudiées afin d'enrichir encore plus cette expressivité des règles. C'est dans cette logique que s'est déroulé notre travail. Il a consisté à s'inspirer de l'article (Chomicky et al) qui utilise des prédicats logiques afin de représenter les relations de préférences.\\
 Ainsi nous allons décrire cette approche dans la sous section suivante puis présenter comment nous avons adapté cette approche pour notre cas spécifique de règles de préférences contextuelles.


\subsection{Formules de préférence suivant les travaux de (\cite{CHO})}

 	Une partie du travail de \cite{CHO} a porté sur l'étude de la représentation des relations de préférences par des formules de prédicat du premier ordre. Ainsi nous avons la définition suivante:

\begin{defn}(formule de préférence)
	Une  \textbf{formule de préférence} $C(t_{1},t_{1})$ est une \textbf{formule de premier ordre} (formule de prédicats) qui est utilisée pour définir une relation de préférence $\succ_{C}$ de telle sorte que $t_{1}\succ_{C} t_{2}\equiv C(t_{1},t_{2})$, c'est à dire la transaction $t_1$ est préférée à la transaction $t_2$ suivant la relation de préférence $\succ_C$ si et seullement si elles vérifient la formule de prédicat $C(t_1,t_2)$.\\
\end{defn}
L'utilisation des formules de préférence nécessite de préciser le type d'attribut auquel les items (des transactions) appartiennent.\\
Ces formules de préférence sont similaires aux \textbf{formes normales disjonctives}(DNF) excepté le fait que les quantificateurs des DNF ne sont pas utilisés dans notre cas. Ainsi elles se présentent comme suit:
 	 \[  
 	 	C(t_{1},t_{2})=\underset{i=1..k}{\bigvee}(\underset{j=1..l}{\bigwedge} f_{ij})
 	 \]
 	  où $f_{ij}$  $\forall i =1..k,\; j=1..l$ sont des \textbf{formules atomiques} (caractérisées par des contraintes de comparaison$= ,\neq,<,>,\leq,\geq$) sous la forme $x\delta y$ ou $x\delta c$ avec $x$ et $y$ des variables (d'un type d'attribut donné) qui correspondent respectivement à la première transaction $t_{1}$ et à la deuxième transaction $t_{2}$. $c$ quand à lui est une constante.\\
 	  $\delta$ prend les valeurs
\begin{itemize}
\item  $=$,$\neq$ dans le cas où les éléments $x,y,c$ sont de type d'attribut quelconque (Exemple: $x=y$,$x=a$,$y\neq a$),  
\item $\leqslant,\geqslant,<,>$ dans le cas où on a à faire à des types d'attributs numériques (Exemple: $x<y$,$x<a$,$y\geqslant a$).
\end{itemize}

 	  \begin{example}
 	  	 
 		  	  En prenant en compte les valeurs numériques, soit deux transactions $t_1=\{x_1,x_2,x_3\}$ et $t_2=\{y_1,y_2,y_3\}$ d'une instance de la relation R(TypeFilm,Annee, Acteur). On a $t_1\succ_C t_2$ ssi:
  		  	\[
 	 		  	\begin{array}{rcl}
 	 		  	C(t_1,t_2)&\equiv&(x_1=y_1\wedge x_2>2010\wedge y_2<2000)\\
 	 		  	&&\vee (x_1=y_1\wedge x_2=y_2\wedge x_3=\text{"Sylvester Stalone"}\wedge y_3=\text{"Pierce Brosnan"})
 	 		  	\end{array}
  		  	\]
  		  	Cette règle veut tout simplement dire que le client préfère pour des films de même genre, des films au delà de 2010 aux films produits avant 2000, et si les films sont de même genre et de même année, il préfère ceux où joue Sylvester Stalone à ceux où joue Pierce Brosnan.
 	  \end{example}
 	



 
\subsection{Formules de préférence suivant notre approche}
 	 Dans notre travail, nous allons nous inspirer de la représentation en formules de préférences décrite précédamment pour l'appliquer au cas des règles de préférence contextuelles. En effet nous voulons définir les formules de préférence de telle sorte qu'elles puissent représenter nos règles de préférence contextuelles.
 	 Dans la section précédante les formules de préférences ont été définies comme suit:
 	 	 \[  
 	 	 	C(t_{1},t_{2})=\underset{i=1..k}{\bigvee}(\underset{j=1..l}{\bigwedge} f_{ij})
 	 	 \]
 	Dans notre contexte, les formules de préférence vont seulement utiliser les connecteurs logiques $\wedge$. C'est à dire elles seront sous la forme: 
 	     \begin{equation}
 	     	 P(t_{1},t_{2})=\underset{k\in E}{\bigwedge} P_{A_{k}}(t_{1},t_{2})
 	     \end{equation}
 	     	
     
      avec $E\subset \{1,2,..,n\}$ où n est le nombre des différents types d'attributs $A_k$ qui définissent les items des transactions $t_1$, $t_2$ et $P_{A_{k}}(t_{1},t_{2}), k\in E$  est une conjonction de formules atomiques définissant les items pour chaque attribut $A_k, k\in E$ comme 
      
      \begin{example}
 	     Pour deux transactions $t_1=\{x_1,x_2\}$ et $t_2=\{y_1,y_2\}$, on a que $t_1\succ_P t_2$ ssi $P(t_1,t_2)=\{x_1=y_1\}\wedge \{x_2>4\}\wedge \{y_2<3\}$ est vrai.\\
      \end{example}
     


Après avoir définit les formules de préférence élémentaires, nous allons définir les formules de préférence.
\begin{defn}
Une \textbf{formule de préférence élémentaire} est une conjonction de formules atomiques (définies dans \cite{CHO}) construites à partir de la comparaison de deux items $x$,$y$ appartenant au même domaine d'attribut.
\end{defn}

\begin{example}
	Si on a deux items $x$ et $y$ définis sur le domaine de l'attribut année, de valeurs respectivement 2000 et 2002, alors en les comparant, on peut déduire les formules de préférence élémentaires $x<y$, $x\neq y$, $x<2003\wedge y<2003$, $x>1999\wedge y> 1999$ etc.. 
\end{example}

Nous fournissons ci dessous les types de formules de préférences élémentaires que nous allons prendre en compte dans notre travail.
Soit $\mathcal{F}$ l'ensemble des formules de préférence élémentaires issues de la comparaison entre deux items de $t_1$ et de $t_2$ ayant un même type d'attribut $A_k$ donné.\\

Les formules de préférences élémentaires qui peuvent être déduites sont:
\begin{itemize}
	
	\item Cas où les items de type $A_k$ ont des valeurs numériques.Soit un item $x$ de $t_1$ de type $A_k$ et $y$ un item de $t_2$ de type $A_k$.\\
	
	\begin{itemize}
	
		\item Si $x$ et $y$ sont tous deux égaux à une valeur $a$ alors les formules de préférences élémentaires extraites sont $x=y$ et $x=y\wedge x=a\wedge y=a$.
		\item Si $x$ est différent de $y$ alors la formule de préférence élémentaire $x\neq y$ est extraite. 

		\begin{itemize}
			\item Si $x<y$ alors la formule de préférence élémentaire $x<y$ est extraite.
			\item Si $x>y$ alors la formule de préférence élémentaire $x>y$ est extraite.
	
		\end{itemize}
		\item Soit $a$ appartennant à l'ensemble des valeurs possibles des items de type $A_k$, 
		\begin{itemize}
			\item $x<a$ et $y<a$ alors la formule de préférence élémentaire $x<a\wedge y<a$ est extraite.
			\item $x>a$ et $y>a$ alors la formule de préférence élémentaire $x>a\wedge y>a$ est extraite. 
			\item $x<a$ et $y\geq a$ alors la formule de préférence élémentaire $x<a\wedge y\geq a$ est extraite 
			\item $x>a$ et $y\leq a$ alors la formule  de préférence élémentaire $x>a\wedge y\leq a$ est extraite.
			\item $y>a$ et $x\leq a$ alors la formule  de préférence élémentaire $y>a\wedge y\leq a$ est extraite.
			\item $y<a$ et $x\geq a$ alors la formule  de préférence élémentaire $y<a\wedge y\geq a$ est extraite.
			\item $x=a$ et $y\neq a$ alors la formule  de préférence élémentaire $x=a\wedge y\neq a$ est extraite.
			\item $y=a$ et $y\neq a$ alors la formule  de préférence élémentaire $y=a\wedge x\neq a$ est extraite.

		\end{itemize}
	\end{itemize}

	\item Cas où pour un type d'attribut donné, les items prennent des valeurs symboliques.\\ 

	\begin{itemize}
		\item Si $x$ et $y$ sont tous deux égaux à une valeur $a$ alors les formules  de préférence élémentaires $x=y$ et $x=y\wedge x=a\wedge y=a$ sont extraites;
		\item Si $x$ est différent de $y$ alors la formule  de préférence élémentaire $x\neq y$ est extraite.\\
	\end{itemize}
\end{itemize}

\subsubsection{Itemsets de formules de préférence élémentaires}

Avant d'aller plus en détail, nous faisons un rappel sur ce que sont les relations binaires symétriques et les relations binaires asymétriques.
\begin{defn}(relation binaire symétrique)
Une relation binaire $\mathcal{R}$ est symétrique si:
\[
\forall (x,y)\in E^2, x\mathcal{R}y\Rightarrow y\mathcal{R}x
\]
\end{defn}

\begin{defn}(relation binaire asymétrique)
	Une relation binaire $\mathcal{R}$ est dite asymétrique si:
\[
	\forall (x,y)\in E^2, x\mathcal{R}y\Rightarrow \neg y\mathcal{R}x
\]
\end{defn}
\begin{defn}(Formules de préférence élémentaires symétriques)
	Les formules  de préférence élémentaires symétriques $C(t_1,t_2)$ sont caractérisées par la propriété de symétrie c'est à dire  $C(t_1,t_2)\Rightarrow  C(t_2,t_1)$. 
		\begin{example}
			la formule $F(x,y)\equiv (x=y)$ est symétrique car $F(x,y)\equiv (x=y)\Rightarrow (y=x)\equiv F(y,x)$, d'où $F(x,y)\Rightarrow F(y,x)$.\\

		\end{example}
\end{defn}

\begin{defn}(Formules de préférence élémentaires asymétriques)
	 Les formules de préférence élémentaires asymétriques $P(t_1,t_2)$ (ou resp $N(t_1,t_2)$) sont caractérisées par la propriété d'asymétrie c'est à dire $P(t_1,t_2)\Rightarrow \neg P(t_2,t_1)$ (ou resp $N(t_1,t_2)\Rightarrow \neg N(t_2,t_1)$ ).
		\begin{example}

			la formule $F(x,y)\equiv (x>y)$ est asymétrique car $F(x,y)\equiv (x>y)\Rightarrow \neg (y>x\vee y=x)\Rightarrow \neg(y>x)\wedge\neg(x=y) \Rightarrow \neg(y>x) \equiv\neg F(y,x)$, d'où $F(x,y)\Rightarrow \neg F(y,x)$.\\
		\end{example}
\end{defn}


L'approche Sprex a définit trois parties dans l'itemset représentant une paire de transaction $\left<t_1,t_2\right>$ à savoir une partie \textit{contextuelle} qui rassemble les items communs à $t_1$ et $t_2$ une la partie \textit{préférée} distinguant les items qui sont dans $t_1$ et pas dans $t_2$ et une partie \textit{non préférée} distinguant les items qui sont dans $t_2$ et pas dans $t_1$.\\
Dans notre approche les items sont des formules de préférence élémentaires.\\
Ainsi nous définissons différamment la composition des itemsets de formules de préférence élémentaires. Ils sont décomposés en deux parties: une partie rassemblant les formules de préférences élémentaires symétriques, appellée partie contexte, et une partie rassemblant les formules de préférence élémentaires asymétriques, appellée partie préférence.\\
Cette approche s'explique par le fait que la partie contexte regroupe les formules vérifiées autant par la paire de transaction $\left<t_1,t_2\right>$ que $\left<t_2,t_1\right>$ (ce sont les formules de préférence élémentaires symétriques). La partie préférence rassemble les formules de préférence élémentaires qui sont en accord avec la paire de transaction $\left<t_1,t_2\right>$ mais en contradiction avec la paire de transaction $\left<t_2,t_1\right>$ (ce sont les formules de préférence élémentaires asymétriques).\\

Ainsi nous résumons un itemset de formules de préférences élémentaires comme suit:
\begin{defn}(Itemset de formules de préférence élémentaire)
Pour une paire de transaction $\left<t_1,t_2\right>$, l'itemset de formules de préférence élémentaires correspondant est l'union de deux itemsets $C$ et $PN$ tel que:\\ 
\begin{itemize}
	\item	$C\equiv\{F(t_1,t_2)/F(t_1,t_2)\in \mathcal{F}(t_1,t_2)\text{ et  symétrique}\}$
	\item	$PN\equiv\{F(t_1,t_2)/F(t_1,t_2)\in \mathcal{F}(t_1,t_2)\text{ et  asymétrique}\}$
\end{itemize}
\end{defn}
avec $\mathcal{F}(t_1,t_2)$ qui est l'ensemble des formules de préférence élémentaires extraites de la comparaison entre les items de $t_1$ et de $t_2$.\\

Voici un diagramme répertoriant les formules de préférence élémentaires réparties suivant qu'elles soient symétriques ou asymétriques:


 
       \[
       \begin{array}{l l}
       \parbox{5.5cm}{Formules de préférence élémentaires symétriques\\ (Contexte)}&
 	  \left\{
 		  \begin{array}{l c l}
 		     C:\{x=y\}&\equiv& x=y\\
 		     C:\{x\neq y\}&\equiv& x\neq y\\
 		   	 C:\{x,y=a\}&\equiv& x=y\wedge x=a\wedge y=a\\
 		   	 C:\{x,y<a\}&\equiv& x<a\wedge y<a\\
 		   	 C:\{x,y>a\}&\equiv& x>a\wedge y>a
 	   	 \end{array}
    	 \right.\\
 	&\\
       \parbox{3.5cm}{Formules de préférence élémentaires asymétriques\\ (Préférences)}&
 	  \left\{
 		  \begin{array}{l c l}   	 
 		   	 P:\{x<y\}&\equiv& x<y\\
 		   	 P:\{x>y\}&\equiv& x>y\\
 		   	 P:\{x=a\} &\equiv& x=a \wedge x\neq y \\
 		   	 P:\{x<a\} &\equiv& x<a \wedge y\geqslant a\\
 			 P:\{x>a\} &\equiv& x>a \wedge y\leqslant a\\
 			 
 			 N:\{y>a\} &\equiv& y>a \wedge x\leqslant a\\
 			 N:\{y<a\} &\equiv& y<a \wedge x\geqslant a\\
 		   	 N:\{y=a\} &\equiv& y=a \wedge x\neq y\\	 
 	   	 \end{array}
    	 \right.
    	 \end{array}
    	 \]		  

Dans ce diagramme, nous avons à droite des équivalences ($\equiv$), les formules de préférences élémentaires et à gauche nous avons leur notation ($C:\{...\}$, $P:\{...\}$,$N:\{...\}$) qui sera adoptée lors de leur représentation au niveau des séquences de formules de préférence.




Nous pouvons à présent définir les formules de préférence qui vont caractériser les règles de préférence contextuelles qu'on aura à extraire.
	\begin{defn}(Règle de préférénce contextuelle à base de formules de préférences élémentaires)
		Une règle de préférence contextuelle à base de formules de préférence élémentaire est une règle sous la forme $C\rightarrow XY$ où $C$ est un itemset de formules de préférences élémentaires symétriques et $XY$ est un itemset de formules de préférences élémentaires asymétriques. Ainsi on la résume part:
 	\[
 	\begin{array}{rcl}
 			C(t_{1},t_{2})&=&\underset{k\in E}{\bigcup} C_{A_{k}}(t_{1},t_{2}) \text{ ensemble de formules de préférence élémentaires symétriques}\\
 			XY(t_{1},t_{2})&=&\underset{k\in E}{\bigcup} XY_{A_{k}}(t_{1},t_{2})\text{ ensemble de formules de préférence élémentaires asymétriques}\\  	
	\end{array}
 	\]
 
 	\end{defn}
	$C(t_1,t_2)$ est défini comme  la \textbf{partie contexte}  de la règle de préférence contextuelle et $PN(t_1,t_2)$ est définie comme la \textbf{partie préférence} de la règle de préférence contextuelle.\\


       	\textbf{Condition de non redondance:}\\
       	Il est à noter que $XY_{A_{k}}$ ne doit pas contenir de redondance i.e si on considère $F_{k}$ l'ensemble des formules élémentaires constituant $P_{A_{k}}$ ($P_{A_{k}}=\underset{f\in F_{k}}{\bigwedge f}$), on a 
       	\[
       	 F'\subsetneq F\Rightarrow \neg (\underset{f\in F'}{\bigwedge f}\Rightarrow P_{A_{k}}).
       	\]
 	C'est la notion de minimalité au niveau des règles qui permettra d'éliminer les règles de préférences contextuelles ayant des redondances.


Le tableau ci dessous résume les différents cas évoqués en ce qui concerne les formules de préférence élémentaires:
 	 
 	\begin{center}
 	   \begin{tabular}{l|l|l|l|} 
 	   \cline{2-4}
 	     & \textbf{Valeurs Attr}& \textbf{Type Attr}& \textbf{Items de transaction de préférence}\\
 	    \hline
 	 	     	\parbox[t]{2mm}{\multirow{13}{*}{\rotatebox[origin=c]{90}{Attr monovalué}}}&
 	 	  		\multirow{4}{*}{\parbox{2cm}{$x=a,\; y=a$}} & \multirow{2}{*}{\parbox{2cm}{num/symb}} &$C:\{ x=y\}$\\
 	 	  		&&& $C:\{ x,y=a\}$\\
 	 	  		\cdashline{3-4}
 	 	  		&&\multirow{2}{*}{\parbox{2cm}{num}}& $C:\{ x,y<c\},\; \forall c| c< a$\\
 	 	  		&&& $C:\{ x,y>c\},\; \forall c| c> a$\\
 	 	    \cline{2-4}
 	 	  		&\multirow{9}{*}{\parbox{2cm}{$x=a,\; y=b$ avec $a\neq b$}}
 	 	  		&\multirow{3}{*}{\parbox{2cm}{num/symb}} & $P:\{ x=a\}$\\
 	 	  		&&& $N:\{ y=b\}$\\
 	 	  		&&& $C:\{ x\neq y\}$\\
 	 	  		\cdashline{3-4}
 	 	  		&&\multirow{8}{*}{\parbox{2cm}{num}}& $P:\{ x<y\},$ si $a<b$\\
 	 	  		&&& $P:\{ x>y\},$ si $a>b$\\
 	 	  		&&& $P:\{ x<c\},$ si $a<b$ et $\forall c |a<c\leqslant b$\\
 	 	  		&&& $P:\{ x>c\},$ si $a>b$ et $\forall c |a>c\geqslant b$\\
 	 	  		&&& $N:\{ y<c\},$ si $a>b$ et $\forall c |b<c\leqslant a$\\
 	 	  		&&& $N:\{ y>c\},$ si $a<b$ et $\forall c |b>c\geqslant a$\\
 	 	  		
 	 	  		&&& $C:\{ x,y<c\},\; \forall c| c< a\wedge c<b$\\
 	 	  		&&& $C:\{ x,y>c\},\; \forall c| c> a\wedge c>b$\\
 	 	  		
 	    \hline
 	   	     	 \parbox[t]{2mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{Attr multivalué}}}&
 	    \multirow{3}{*}{\parbox{2cm}{$x\in X, y\in Y$}} & \multirow{3}{*}{\parbox{2cm}{Set(symb)}} & $C:\{ x,y=c\},\;\forall c\in X\cap Y$\\
 	    &&&$P:\{ x=a\},\;\forall a\in X\backslash Y$\\
 	    &&&$N:\{ y=b\},\;\forall b\in Y\backslash X$\\
 	    &&&\\	  		
 	    &&&\\
 	    &&&\\		 	   
 	    \hline 
 
 	   \end{tabular}
 	   \end{center} 

\bigskip
	
       





 
        
     \subsection{Construction du profil utilisateur}
De façon générale, pour passer des paires de transaction à un profil utilisateur, plusieurs étapes de traitement sont effectuées comme le montre le schémas ci dessous:

  \begin{center}

        \begin{tikzpicture}[
                auto,
                decision/.style = { diamond, draw=blue, thick, fill=blue!20,
                                    text width=5em, text badly centered,
                                    inner sep=1pt, rounded corners },
                block/.style    = { rectangle, draw=blue, thick,
                                    fill=blue!20, text width=10em, text centered,
                                    rounded corners, minimum height=2em },
                line/.style     = { draw, thick, ->, shorten >=2pt },
              ]
              % Define nodes in a matrix
              \matrix [column sep=5mm, row sep=10mm] {
                      & \node [block] (PT)
                                {Paires de transaction}; & \\
                      & \node [block] (IF)
                          {Itemsets de formules de préférence};            & \\
                      & \node [block] (RPI)
                          {Règles de préférence interressantes};          & \\
                     & \node [block] (PP)
                                    {Profil de préférence};          & \\
            };
              % connect all nodes defined above
              \begin{scope} [every path/.style=line]
                        \path (PT)    --    node [near start] { FormulaItemset} (IF);
                        \path (IF)    --    node [near start] { InterestingRules} (RPI);
                        \path (RPI)    --    node [near start] { $\pi$ (fonction de modélisation)} (PP);
              \end{scope}

            \end{tikzpicture}
      \end{center}


L'algorithme d'extraction du profil \textit{FormulaProfileMining} que nous définissons est construit suivant ces étapes.\\ 

\begin{algorithm}[H]
	\Entree{l'ensemble des paires de transactions de préférence $\mathcal{P}$, un seuil minimal de support $\delta$, un seuil minimal de confiance $\sigma$ et une fonction de modélisation $\pi$}
 	\Sortie{Modèle de règles de préférences $\mathcal{M}_\mathcal{P}$}
 	   	
 	   	\Deb{
 	   		$\mathcal{P}_S=\mathcal{N}_S=\emptyset$\;
 	   		\PourCh{$\left<T,U\right>\in \mathcal{P}$}{
				$\mathcal{P}_S =\mathcal{P}_S\cup FormulaItemset(\left<T,U\right>)$\;	
				$\mathcal{N}_S =\mathcal{N}_S\cup FormulaItemset(\left<U,T\right>)$\;	
			}
			$\mathcal{M}=InterestingRules(\mathcal{P}_S,\mathcal{N}_S,\delta,\sigma)$\;
			$\mathcal{M}_\mathcal{P}=\pi(sort(\mathcal{M}))$\;
			\textbf{Retourner} $\mathcal{M}_{\mathcal{P}}$;
 			}
	\caption{FormulaProfileMining}
\end{algorithm}
Ici $\mathcal{P}_S$ est appellé ensemble des itemsets positifs et $\mathcal {N}_S$ est appellé ensemble des itemsets négatifs.
\textit{FormulaItemset} permet la transformation d'une paire de transaction $\left< T, U\right>$ en un Itemset de formules de préférences élémentaires. Elle est définie comme suit:\\

 
\begin{algorithm}[H]
	\Entree{Paire de transactions $\left<T,U\right>$}
 	\Sortie{Itemset de formules de préférence $S$}
 	   	
 	   	\Deb{
 	   		$S=\emptyset$\;
 	   		\PourCh{Type d'attribut $A_k$}{
	 	   		\PourCh{paire d'items $(x,y)\in T\times U$ de type $A_k$}{
					$S=S\cup CompareFormula(x,y,A_k)$
				}
			}

		}
	\caption{FormulaItemset}
\end{algorithm}

\textit{CompareFormula} effectue la comparaison entre deux items respectivement de $T$ et $U$ afin de générer les formules de préférences élémentaires correspondantes. Elle est définie comme suit:\\
 	   \begin{algorithm}[H]
 	   	\Entree{x , y et l'attribut $A_{i}$ auquel ils sont liés}
 	   	\Sortie{items issus de la comparaison entre x et y}
 	   	
 	   	\Deb{
 	   		$\mathcal{E}=\emptyset$ \tcp*[r]{Ensemble des items générés}
 	   		
 	   		\uSi{$x=y$}
 	   		{
 	   			Ajouter $P:\{x_{A_{i}}=y_{A_{i}}\}$ et $P:\{x_{A_{i}}=y_{A_{i}}=x\}$ à $\mathcal{E}$\;
 	   			\PourCh{$c\in DomActif(A_{i})$ et $A_{i}$ numérique}
 	   			{
 	   				\uSi{$x<c$}
 	   				{
 	   					Ajouter $C:\{x_{A_{i}},y_{A_{i}}<c\}$ à $\mathcal{E}$\;
 	   				}
 	   				\SinonSi{$x>c$}
 	   				{
 	   					Ajouter $C:\{x_{A_{i}},y_{A_{i}}>c\}$ à $\mathcal{E}$\;
 	   				}
 	   			
 	   			}					
 	   		}
 	   		\SinonSi{$x\neq y$}
 	   		{
 	   			Ajouter $C:\{x_{A_{i}}\neq y_{A_{i}}\}$, $P:\{x_{A_{i}}=x\}$ et $N:\{y_{A_{i}}=y\}$ à $\mathcal{E}$\;
 	   
 	   			\Si{$A_{i}$ numérique}
 	   			{
 	   				\Si{$x> y$}
 	   				{
 	   						Ajouter $P:\{x_{A_{i}}> y_{A_{i}}\}$ à $\mathcal{E}$\;
 	   				}
 	   				\Si{$x< y$}
 	   				{
 	   						Ajouter $P:\{x_{A_{i}}< y_{A_{i}}\}$ à $\mathcal{E}$\;
 	   				}
 	   				\PourCh{$c\in DomActif(A_{i})$}
 	   				{
 	   					\uSi{$x<c\wedge y\geqslant c$}
 	   					{
 	   						Ajouter $P:\{x_{A_{i}}<c\}$ à $\mathcal{E}$\;
 	   					}
 	   					\uSinonSi{$x\leqslant c\wedge y> c$}
 	   					{
 	   						Ajouter $N:\{y_{A_{i}}>c\}$ à $\mathcal{E}$\;
 	   					}
 	   					\uSinonSi{$x>c\wedge y \leqslant c$}
 	   					{
 	   						Ajouter $P:\{x_{A_{i}}>c\}$ à $\mathcal{E}$\;
 	   					}
 	   					\uSinonSi{$x\geqslant c\wedge y < c$}
 	   					{
 	   						Ajouter $N:\{x_{A_{i}}<c\}$ à $\mathcal{E}$\;
 	   					}
 	   					\uSinonSi{$x<c\wedge y<c$}
 	   					{
 	   						Ajouter $C:\{x_{A_{i}},y_{A_{i}}<c\}$ à $\mathcal{E}$\;
 	   					}
 	   					\SinonSi{$x>c\wedge y>c$}
 	   					{
 	   						Ajouter $C:\{x_{A_{i}},y_{A_{i}}>c\}$ à $\mathcal{E}$\;
 	   					}
 	   					
 	   				}
 	   				
 	   			}
 	   		}
 	   		
 	   	retourner $\mathcal{E}$\;
 	   	}
 	   	\caption{CompareFormula}
 	   \end{algorithm}

 	
     Cette fonction est équivalente à la description qu'on avait faite antérieurement sur les formules de préférence élémentaires qui peuvent re générées par la comparaison de deux items.\\


\subsubsection{L'algorithme InterestingRules}
Au cours des travaux, l'extraction des itemsets interressants minimaux était faite à l'aide de du programme Sprex mais nous avons été confrontés à un problème de saturation mémoire du fait que la nouvelle formulation à base  de formules de préférence était caractérisée par des itemsets de plus grande taille que les itemsets traités dans les travaux de Sprex.
C'est pour cela que nous avons exploité un algorithme fondé sur les travaux de \cite{SOUL}. Ce algorithme a été modifié afin de prendre en compte la notion de confiance. On l'appellera InterrestingRules et on le définit ci après:


\begin{algorithm}[H]
        \Entree{Ensemble des itemsets de formules de préférence $\mathcal{P}_S$ et $\mathcal{N}_S$, support seuil $\sigma$, confiance seuil $\delta$}
        \Sortie{Règles de préférence Interressantes minimales $\mathcal{R}$}
                
                \Deb{
			$\mathcal{R}=\emptyset$\;
			$\mathcal{F}=\mathcal{P}_S\cup\mathcal{N}_S$\;
			$\mathcal{I}=$Ensemble des items utilisés dans $\mathcal{F}$\;
                        
			\PourCh{$i\in \mathcal{I}$}{
				$cov(\{i\})=$Cardinal des itemsets de F contenant $i$\;
				$cov_{pos}(\{i\})=$ Cardinal des itemsets de $\mathcal{P}_S$ contenant $i$\;
				$\widehat{cov}(\{i\},i)=\mathcal{F}\mysetminus cov(\{i\})$
			}
			
			
			\PourCh{$i\in \mathcal{I}$}{
				DEFMEMODIF($\{i\}, \mathcal{I}\mysetminus \{i\}$)
			}
                }
        \caption{InterestingRules}
\end{algorithm}



\textbf{Algorithme DEFMEMODIF}


\begin{algorithm}[H]
	 \Entree{$X$ est un motif, tail est l'ensemble des items restant à utiliser pour générer les candidats.}
	\Sortie{Calcul des itemset interessants minimaux de manière incrémentale polynomiale}

                \Deb{

                        \Si{$\forall e \in X,\widehat{cov}(X,e)\neq \emptyset$ et $|cov_{pos}(X)|>\delta$ et $|cov_{pos}(X)|/|cov(X)|>\sigma$}{
                                print $X$\;
                                \PourCh{$e\in tail$}{
                                                $tail:=tail\mysetminus\{e\}$\;
                                                $Y:=Xe$\;
                                                $cov(Y):=cov(X)\cap cov(e)$\;
						$cov_{pos}(Y)=cov_{pos}(X)\cap cov_{pos}(e)$\;
                                                $\widehat{cov}(Y,e):=cov(X)\mysetminus cov(e)$\;

                                                \PourCh{$e'\in X$}{
                                                        $\widehat{cov}(Y,e'):=\widehat{cov}(X,e')\cap cov(e)$\;
                                                }
                                                DEFME($Y,tail$)\;
                                }
                        }
                }
                \caption{DEFMEMODIF}
\end{algorithm}
Comme décrit dans l'algorithme InterestingRules $\mathcal{F}$ rassemble les itemsets positifs et négatifs. 
Ici pour tout itemset candidat $X$:
\begin{itemize}
\item $cov(X)$ est le sous ensemble des Itemsets contenant $X$ dans l'ensemble $\mathcal{F}$.
\item $cov_{pos}(X)$ est le sous ensemble des Itemsets contenant $X$ dans l'ensemble $\mathcal{P}_S$.
\item Pour un item $e$ de $X$, $\widehat{cov}(X,e)$ est le sous ensemble des Itemsets contenant $X\mysetminus\{e\}$ mais ne contenant pas $e$.
\end{itemize}
Ainsi par ces sous ensembles:
\begin{itemize}
\item le support d'un itemset $X$ est déterminé par $|cov(X)|$,
\item la confiance par $|cov_{pos}(X)|/|cov(X)|$,
\item la minimalité de $X$ est vérifiée si $\forall e$ dans $X$, $\widehat{cov}(X,e)\neq 0$
\end{itemize}

Nous constatons que cet algorithme est un algorithme effectue un parcours en profondeur qui a l'avantage de réduire l'espace mémoire necessaire aux traitements. 

        
        
        
    \subsection{Exemple d'extraction des règles de préférence}
        \subsubsection{Cas où le schémas relationnel a des attributs numériques et symboliques}
        	Prenons un schémas relationnel $\mathcal{R}(\mathcal{A}_{1},\mathcal{A}_{2})$ avec $A_{1}$ et $A_{2}$ de type symboliques. Soit la base de préférence ci dessous:
        	\begin{center}
        	\begin{tabular}{l|l|l|l|l| } 
        	
        	&\multicolumn{2}{c|}{$t_{1}$} & \multicolumn{2}{c|}{$t_{2}$}\\
        	\cline{2-5}
        		$P_{1}$ & a & 3 & b & 7\\
        		$P_{2}$ & a & 3 & b & 3\\		
        		$P_{3}$ & b & 3 & a & 7\\
        		$P_{4}$ & a & 3 & a & 7\\
        		$P_{5}$ & a & 3 & a & 9\\
        		$P_{6}$ & b & 9 & a & 7\\
        		$P_{7}$ & b & 7 & a & 3\\
        	\cline{2-5}
        	\end{tabular}
        	\end{center}
        
        
        Transactions de preference obtenues\\
        
        \noindent $P_{1}\Rightarrow T_{1}=\{C:\{x_{1}\neq y_{1}\},P:\{x_{1}=a\},N:\{y_{1}=b\},C:\{x_{2}\neq y_{2}\},P:\{x_{2}=3\},N:\{y_{2}=7\},P:\{x_{2}<y_{2}\},N:\{y_{2}>3\},P:\{x_{2}<7\},C:\{x_{2},y_{2}<9\},\}$ \\
        
        \noindent $P_{2}\Rightarrow T_{2}=\{C:\{x_{1}\neq y_{1}\},P:\{x_{1}=a\},N:\{y_{1}=b\},C:\{x_{2}=y_{2}\},C:\{x_{2},y_{2}=3\},C:\{x_{2},y_{2}<7\},C:\{x_{2},y_{2}<9\},\}$ \\
        
        \noindent $P_{3}\Rightarrow T_{3}=\{C:\{x_{1}\neq y_{1}\},P:\{x_{1}=b\},N:\{y_{1}=a\},C:\{x_{2}\neq y_{2}\},P:\{x_{2}=3\},N:\{y_{2}=7\},P:\{x_{2}<y_{2}\},N:\{y_{2}>3\},P:\{x_{2}<7\},C:\{x_{2},y_{2}<9\},\}$ \\
        
        \noindent $P_{4}\Rightarrow T_{4}=\{C:\{x_{1}=y_{1}\},C:\{x_{1},y_{1}=a\},C:\{x_{2}\neq y_{2}\},P:\{x_{2}=3\},N:\{y_{2}=7\},P:\{x_{2}<y_{2}\},N:\{y_{2}>3\},P:\{x_{2}<7\},C:\{x_{2},y_{2}<9\},\}$ \\
        
        \noindent $P_{5}\Rightarrow T_{5}=\{C:\{x_{1}=y_{1}\},C:\{x_{1},y_{1}=a\},C:\{x_{2}\neq y_{2}\},P:\{x_{2}=3\},N:\{y_{2}=9\},P:\{x_{2}<y_{2}\},N:\{y_{2}>3\},N:\{y_{2}>7\},P:\{x_{2}<7\},P:\{x_{2}<9\},\}$ \\
        
        \noindent $P_{6}\Rightarrow T_{6}=\{C:\{x_{1}\neq y_{1}\},P:\{x_{1}=b\},N:\{y_{1}=a\},C:\{x_{2}\neq y_{2}\},P:\{x_{2}=9\},N:\{y_{2}=7\},P:\{x_{2}>y_{2}\},P:\{x_{2}>7\},N:\{y_{2}<9\},C:\{x_{2},y_{2}>3\},\}$ \\
        
        \noindent $P_{7}\Rightarrow T_{7}=\{C:\{x_{1}\neq y_{1}\},P:\{x_{1}=b\},N:\{y_{1}=a\},C:\{x_{2}\neq y_{2}\},P:\{x_{2}=7\},N:\{y_{2}=3\},P:\{x_{2}>y_{2}\},P:\{x_{2}>3\},N:\{y_{2}<7\},C:\{x_{2},y_{2}<9\},\}$ \\
        
        
       \newpage
       
        \subsection{Determination des itemsets interressants minimaux avec supmin=2 et confmin=0.5}
        
        Itemsets interressants minimaux de taille 1 \\
        
        \noindent $I_{4}=\{P:\{x_{2}=3\},\}$  sup=4.0 conf=0.8\\
        $I_{5}=\{N:\{y_{2}=7\},\}$  sup=4.0 conf=0.8\\
        $I_{6}=\{P:\{x_{2}<y_{2}\},\}$  sup=4.0 conf=0.66\\
        $I_{7}=\{N:\{y_{2}>3\},\}$  sup=4.0 conf=0.8\\
        $I_{8}=\{P:\{x_{2}<7\},\}$  sup=4.0 conf=0.8\\
        $I_{13}=\{P:\{x_{1}=b\},\}$  sup=3.0 conf=0.6\\
        $I_{14}=\{N:\{y_{1}=a\},\}$  sup=3.0 conf=0.6\\
        
        Itemsets interressants minimaux de taille 2 \\
        
        \noindent $I_{32}=\{C:\{x_{1}\neq y_{1}\},P:\{x_{2}=3\},\}$  sup=2.0 conf=0.66\\
        $I_{33}=\{C:\{x_{1}\neq y_{1}\},N:\{y_{2}=7\},\}$  sup=3.0 conf=0.75\\
        $I_{35}=\{C:\{x_{1}\neq y_{1}\},N:\{y_{2}>3\},\}$  sup=2.0 conf=0.66\\
        $I_{36}=\{C:\{x_{1}\neq y_{1}\},P:\{x_{2}<7\},\}$  sup=2.0 conf=0.66\\
        $I_{74}=\{C:\{x_{2}\neq y_{2}\},P:\{x_{1}=b\},\}$  sup=3.0 conf=0.75\\
        $I_{75}=\{C:\{x_{2}\neq y_{2}\},N:\{y_{1}=a\},\}$  sup=3.0 conf=0.75\\
        $I_{79}=\{P:\{x_{2}=3\},N:\{y_{2}=7\},\}$  sup=3.0 conf=0.75\\
        $I_{83}=\{P:\{x_{2}=3\},C:\{x_{2},y_{2}<9\},\}$  sup=3.0 conf=0.75\\
        $I_{86}=\{P:\{x_{2}=3\},C:\{x_{1}=y_{1}\},\}$  sup=2.0 conf=1.0\\
        $I_{87}=\{P:\{x_{2}=3\},C:\{x_{1},y_{1}=a\},\}$  sup=2.0 conf=1.0\\
        $I_{89}=\{N:\{y_{2}=7\},P:\{x_{2}<y_{2}\},\}$  sup=3.0 conf=0.75\\
        $I_{90}=\{N:\{y_{2}=7\},N:\{y_{2}>3\},\}$  sup=3.0 conf=0.75\\
        $I_{91}=\{N:\{y_{2}=7\},P:\{x_{2}<7\},\}$  sup=3.0 conf=0.75\\
        $I_{92}=\{N:\{y_{2}=7\},C:\{x_{2},y_{2}<9\},\}$  sup=3.0 conf=0.75\\
        $I_{93}=\{N:\{y_{2}=7\},P:\{x_{1}=b\},\}$  sup=2.0 conf=1.0\\
        $I_{94}=\{N:\{y_{2}=7\},N:\{y_{1}=a\},\}$  sup=2.0 conf=1.0\\
        $I_{100}=\{P:\{x_{2}<y_{2}\},C:\{x_{2},y_{2}<9\},\}$  sup=3.0 conf=0.75\\
        $I_{103}=\{P:\{x_{2}<y_{2}\},C:\{x_{1}=y_{1}\},\}$  sup=2.0 conf=1.0\\
        $I_{104}=\{P:\{x_{2}<y_{2}\},C:\{x_{1},y_{1}=a\},\}$  sup=2.0 conf=1.0\\
        $I_{107}=\{N:\{y_{2}>3\},C:\{x_{2},y_{2}<9\},\}$  sup=3.0 conf=0.75\\
        $I_{110}=\{N:\{y_{2}>3\},C:\{x_{1}=y_{1}\},\}$  sup=2.0 conf=1.0\\
        $I_{111}=\{N:\{y_{2}>3\},C:\{x_{1},y_{1}=a\},\}$  sup=2.0 conf=1.0\\
        $I_{113}=\{P:\{x_{2}<7\},C:\{x_{2},y_{2}<9\},\}$  sup=3.0 conf=0.75\\
        $I_{116}=\{P:\{x_{2}<7\},C:\{x_{1}=y_{1}\},\}$  sup=2.0 conf=1.0\\
        $I_{117}=\{P:\{x_{2}<7\},C:\{x_{1},y_{1}=a\},\}$  sup=2.0 conf=1.0\\
        $I_{127}=\{P:\{x_{1}=b\},P:\{x_{2}>y_{2}\},\}$  sup=2.0 conf=0.66\\
        $I_{130}=\{N:\{y_{1}=a\},P:\{x_{2}>y_{2}\},\}$  sup=2.0 conf=0.66\\
        
        Itemsets interressants minimaux de taille 3 \\
        
        \noindent $I_{151}=\{C:\{x_{1}\neq y_{1}\},N:\{y_{2}=7\},P:\{x_{2}<y_{2}\},\}$  sup=2.0 conf=0.66\\
        $I_{154}=\{C:\{x_{2},y_{2}<9\},C:\{x_{1}\neq y_{1}\},N:\{y_{2}=7\},\}$  sup=2.0 conf=0.66\\
        $I_{160}=\{C:\{x_{2},y_{2}<9\},C:\{x_{1}\neq y_{1}\},P:\{x_{2}<y_{2}\},\}$  sup=2.0 conf=0.66\\
        $I_{197}=\{C:\{x_{2},y_{2}<9\},C:\{x_{2}\neq y_{2}\},P:\{x_{1}=b\},\}$  sup=2.0 conf=0.66\\
        $I_{198}=\{C:\{x_{2},y_{2}<9\},C:\{x_{2}\neq y_{2}\},N:\{y_{1}=a\},\}$  sup=2.0 conf=0.66\\
 
Les différentes étapes de la construction de profils de préférence iétant décrites, on peut décrire la phase de prédiction des préférences utilisateur à partir de ce profil obtenu. 

\subsection{Prédiction des préférences utilisateur}
Le modèle de préférence construit, la phase de prédiction est similaire à celle de Sprex. Ce qui nous a permit de pouvoir utiliser Sprex-predict pour evaluer la prédiction de nos modèles.\\

\section{Evaluations expérimentales}
La performance d'une approche en terme de prédiction des préférences est évaluée en fonction de différents indicateurs. Nous allons dans ces travaux nous fonder sur les critères de précision et de rappel que nous allons définir ci dessous:

\begin{defn}(Précision)
La précision est un critère qui permet de vérifier le taux de transactions de préférences qui sont en accord avec un modèle par rapport au total des transactions qui sont en accord et en contradicon avec ce modèle.
\[
	Prec(\succ,\mathcal{P})=\frac{|\{\left< t,u\right> \in \mathcal{P}/t\succ u\}|}{|\{\left< t,u\right> \in \mathcal{P}/t\succ u\vee u\succ t\}|}
\]
\end{defn}


\begin{defn}(Rappel)
Le rappel est le critère qui permet de vérifier le taux de transactions de préférences qui sont en accord avec un modèle par rapport à toutes les transactions de préférence.
\[
	Rec(\succ,\mathcal{P})=\frac{|\{\left< t,u\right> \in \mathcal{P}/t\succ u\}|}{|\mathcal{P}|}
\]

\end{defn}

Dans cette section, nous nous atellons à evaluer les performaces de notre approche part rapport au travail antérieur à base de séquences de préférence (Sprex). Nous avons utilisé des données mises à disposition par MoviLens et IMDB. 
Nos expérimentations ont été effectuées sur un serveur 16-Core 2.40GHz Intel Xeon avec 32giga-octets de mémoire vive. L'implémentation a été effectuée en C++ et en Python. Nous avons utilisé un jeux de données de 5 utilisateurs identifiés par u0651-478 u0777-502 u1701-552 u2402-529 u2419-528. Chaque jeux de donné a été divisé en 4 parties puis on y a appliqué la validation croisée en prenant les $3/4$ de chaque jeux comme données d'extraction du modèle et le $1/4$ restant comme jeux de données d'évaluation de la prédiction des modèles. Ceci est résumé ci dessous:



\begin{algorithm}[H]

                \Deb{

                        \PourCh{valeur de confiance et de support}{
        	                \PourCh{Jeux de données}{
				\tcp*{ Etape de validation croisée}
 	        	               	Diviser le jeux en 4 sous jeux\;
				
					\PourCh{sous jeux}{
						Le définir comme sous jeux d'évaluation\;
						Prendre le reste du jeux de données comme sous jeux d'extraction\;
						Extraire le modèle du sous jeux d'extraction\;
						Calculer les indicateur de précision et de rappel du model en evaluant le modèle sur le sous jeux d'évaluation\;
        	                	}
					Calculer la moyenne de chaque indicateur de performance calculés sur les 4 sous jeux d'évaluation\;
                        	}
				Effectuer la moyenne de chaque indicateur de performance sur les 4 jeux de données\;
			}
	}
        \caption{Etapes d'évaluation}
\end{algorithm}

Ces étapes nous ont permis d'obtenir les résulats (précision et rappel) représentés dans les graphes ci dessous. Nous avons effectué les traitements sur des valeurs de support variant de 0.012 à 0.02 avec un écart de 0.002 et sur des valeurs de confiance variant de 0.7 à 0.9 avec un écart de 0.05.Les courbes en orange représente la formulation standard définie dans le travail antérieur (Sprex) et les courbes en bleu représentent les valeurs obtenue pavec la nouvelle formulation des itemsets proposée dans ce travail (formules de préférence).

\begin{figure}
\centering
\noindent \includegraphics[height=7cm]{p12.png}
\includegraphics[height=7cm]{r12.png}
\caption{Précision et rappel avec un support de 0.012}
\label{fig:length_eight_mouse}
\end{figure}
\begin{figure}
\centering
\includegraphics[height=7cm]{p14.png}
\includegraphics[height=7cm]{r14.png}
\caption{Précision et rappel avec un support de 0.014}
\label{fig:length_eight_mouse}
\end{figure}
\begin{figure}
\centering
\includegraphics[height=7cm]{p16.png}
\includegraphics[height=7cm]{r16.png}
\caption{Précision et rappel avec un support de 0.016}
\label{fig:length_eight_mouse}
\end{figure}
\begin{figure}
\centering
\includegraphics[height=7cm]{p18.png}
\includegraphics[height=7cm]{r18.png}
\caption{Précision et rappel avec un support de 0.018}
\label{fig:length_eight_mouse}
\end{figure}
\begin{figure}
\centering
\includegraphics[height=7cm]{p2.png}
\includegraphics[height=7cm]{r2.png}
\caption{Précision et rappel avec un support de 0.02}
\label{fig:length_eight_mouse}
\end{figure}




\subsection{Interprétation}
Nous pouvons remarquer que les courbes des précisions (figures 1 à 5 graphes de gauche) pour chaque valeur de support, sont pratiquement similaires hormis le fait que les courbes des formules de préférence sont distinctement au dessus des courbes de Sprex dans le cas où la confiance est supérieure à 0.8. 
Du côté des courbes des rappels (figures 1 à 5 graphes de droite) les courbes des formules de préférences sont au dessus des courbes de Sprex et l'écart s'accroit considérablement lorsque la valeur de la confiance croit au delà de 0.7. 

Par l'analyse sur la précision, nous pouvons alors conclure que le taux des prédictions des préférences vraies des modèles de préférence dans les deux formulations est similaire. Par contre les analyses sur les courbes des rappels nous permettent de déduire que le taux d'indécision sur la prédiction des préférences (cas où le modèle ne peut prédire la préférence entre deux transactions) est considérablement plus bas dans le cas des formules de préférence d'où il y'a plus de chance que les modèles des formules de préférence arrivent à proposer une prédiction de la préférence entre deux transactions données.
Ceci est rendu possible du fait que les items de formules de ppréférence on des propriétés qui permettent de plus généraliser les transactions. C'est comme le cas où par exemple ne règle à base de formule de préférence indique que les valeurs au delà de la veleur 5 sont plus préférées que les valeurs inférieure à 5. Elle est plus générale qu'une règle indiquant par exemple que la valeur 6 est préférée à la valeur 4. Ainsi l'approche par formule de préférence a l'avantage de réduire les cas d'indécisions.
La contrepartie par rapport à cet avantage est que l'extraction des modèle de formules de préférence prend un temps considérable et un plus grand espace de stockage comparé à l'extraction des modèles de préférence de Sprex. 


\section{Conclusion}
Notre travail a eu pour but d'améliorer l'expressivité des règles de préférence contextuelles en modifiant la formulation proposée dans les travaux de Arnault G. et al. L'utilisation des représentations à l'aide des formules de préférences basées sur des  prédicats logiques, nous a permit de proposer une formulation qui permet d'étendre la couverture des règles de préférence. Nous avons pu ainsi constater une réduction du taux d'indécidabilité des prédictions par rapport au travail antérieur portant sur Sprex. 
Nous avions été confrontés à plusieurs problèmes qui ont necessité un temps considérable afin  de les résoudre. Ainsi la constitution des nouvelles formulations des items élémentaires sous forme de formule de préférence a necessité de les analyser afin d'éliminer la redondance dans la composition des règles, d'aboutir à la notion de symétrie et d'assymétrie des items de formule de préférence dans la composition des règles de préférence. De même comme nous l'avions expliqué, nous avions utilisé le programme de Sprex pour l'extraction des règles de préférence interressantes minimales mais nous avons été confronté à un problème de saturation mémoire qui n'a pas pu être résolut malgré de multiples tentatives d'amélioration du programme Sprex. C'est ce qui nous a mené au final vers l'utilisation du programme basé sur l'algorithme InterestingRules, qui nous a permit de résoudre ce problème de congestion mémoire. De même les différentes phases de traitement de la phase d'extraction à la phase de prédiction ont necessité un temps considérable afin d'obtenir les résultats finaux d'évaluation.
Tout de même nous sommes satisfaits d'avoir obtenu un résultat comparatif des deux travaux mais nous espérions une amélioration des valeurs de précison, ce qui n'a pas répondu à nos attentes.
Ainsi comme perspectives nous proposons une amélioration de la formulation afin d'améliorer les valeurs des précisions.
	\bibliographystyle{plain}
	\bibliography{./biblio}




\end{document}


 
